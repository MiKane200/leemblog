## 谈到Java应用安全，主要涉及哪些安全机制？
1. 注入式（Inject）攻击
    1. SQL注入攻击
    2. 操作系统命令注入Java语言提供了类似Runtime.exec(…)的API，可以用来执行特定命令，假设我们构建了一个应用，以输入文本作为参数，执行下面的命令：`ls –la input_file_nam`,但是如果用户输入是 `input_file_name;rm –rf /*`，这就有可能出现问题了。
    3. XML注入攻击。Java核心类库提供了全面的XML处理、转换等各种API，而XML自身是可以包含动态内容的，例如XPATH，如果使用不当，可能导致访问恶意内容。

## Java API和工具构成了Java安全基础
1. 运行时安全机制。可以简单认为，就是限制Java运行时的行为，不要做越权或者不靠谱的事情，具体来看：
    1. 在类加载过程中，进行字节码验证，以防止不合规的代码影响JVM运行或者载入其他恶意代码。
    2. 类加载器本身也可以对代码之间进行隔离，例如，应用无法获取启动类加载器（Bootstrap Class-Loader）对象实例，不同的类加载器也可以起到容器的作用，隔离模块之间不必要的可见性等。目前，Java Applet、RMI等特性已经或逐渐退出历史舞台，类加载等机制总体上反倒在不断简化。
    3. 利用SecurityManger机制和相关的组件，限制代码的运行时行为能力，其中，你可以定制policy文件和各种粒度的权限定义，限制代码的作用域和权限，例如对文件系统的操作权限，或者监听某个网络端口的权限等。我画了一个简单的示意图，对运行时安全的不同层次进行了整理。 
    [img](../../../static/img/SecurityManger机制示意图.png)
    4. 可以看到，Java的安全模型是以代码为中心的，贯穿了从类加载，如URLClassLoader加载网络上的Java类等，到应用程序运行时权限检查等全过程。
    * 另外，从原则上来说，Java的GC等资源回收管理机制，都可以看作是运行时安全的一部分，如果相应机制失效，就会导致JVM出现OOM等错误，可看作是另类的拒绝服务。
2. Java提供的安全框架API，这是构建安全通信等应用的基础。例如：
    1. 加密、解密API。
    2. 授权、鉴权API。
    3. 安全通信相关的类库，比如基本HTTPS通信协议相关标准实现，如TLS 1.3；或者附属的类似证书撤销状态判断（OSCP）等协议实现。
    * 注意，这一部分API内部实现是和厂商相关的，不同JDK厂商往往会定制自己的加密算法实现。
3. 就是JDK集成的各种安全工具，例如：
    1. keytool，这是个强大的工具，可以管理安全场景中不可或缺的秘钥、证书等，并且可以管理Java程序使用的keystore文件。
    2. jarsigner，用于对jar文件进行签名或者验证。
    3. 在应用实践中，如果对安全要求非常高，建议打开SecurityManager `-Djava.security.manager`
    * 请注意其开销，通常只要开启SecurityManager，就会导致10% ~ 15%的性能下降，在JDK 9以后，这个开销有所改善。

## 到底什么是安全漏洞？对于前面提到的SQL注入等典型攻击，我们在开发中怎么避免？
1. 任何可以用来绕过系统安全策略限制的程序瑕疵，都可以算作安全漏洞。具体原因可能非常多，设计或实现中的疏漏、配置错误等，任何不慎都有可能导致安全漏洞出现，例如恶意代码绕过了Java沙箱的限制，获取了特权等。
2. 要达到攻击的目的，未必都需要绕过权限限制。比如利用哈希碰撞发起拒绝服务攻击
3. 提到的各种注入式攻击，可以有不同角度、不同层面的解决方法，例如针对SQL注入：
    1. 在数据输入阶段，填补期望输入和可能输入之间的鸿沟。可以进行输入校验，限定什么类型的输入是合法的，例如，不允许输入标点符号等特殊字符，或者特定结构的输入。
    2. 在Java应用进行数据库访问时，如果不用完全动态的SQL，而是利用PreparedStatement，可以有效防范SQL注入。不管是SQL注入，还是OS命令注入，程序利用字符串拼接生成运行逻辑都是个可能的风险点！
    3. 在数据库层面，如果对查询、修改等权限进行了合理限制，就可以在一定程度上避免被注入删除等高破坏性的代码。