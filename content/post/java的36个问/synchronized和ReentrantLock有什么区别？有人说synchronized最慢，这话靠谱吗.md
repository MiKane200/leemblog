## ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。
1. 用法比较
    1. Lock使用起来比较灵活，但是必须有释放锁的配合动作
    2. Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁
    3. Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等
2. 特性比较 ReentrantLock的优势体现在：
      1. 具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
      2. 能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出,同时锁会被释放
      3. 超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回

3. 注意事项 在使用ReentrantLock类的时，一定要注意三点：
    1. 在finally中释放锁，目的是保证在获取锁之后，最终能够被释放
    2. 不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。
    3. ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。

## synchronized与ReentrantLock（实现了lock的）区别
在低竞争条件下，synchronized可能会比Reentrantlock效率更高，但是高竞争绝对是Reentrantlock更高。
Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性；使用synchronized关键字时，如果只是读操作也会加锁，因此其他线程无法读，而lock可实现多个线程同时读；Lock可以让等待锁的线程响应中断，避免等待是因为lock可以知道有没有获取到锁，如果没获取到就干其他事去了，避免一直等待；竞争激烈的时候我觉得在可支持同时读这一点上就提升了不少效率啊

## 锁的升级降级
synchronized 代码块是 由一对儿 monitorenter/monitorexit 指令实现的，Monitor 对象是同步的基本实 现单元。 在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要 进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。 现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同 的 Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、 轻量级锁和重量级锁，大大改进了其性能。 所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测 到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、 降级。 当没有竞争出现时，默认会使用偏斜锁。

## 偏斜锁
JVM 会利用 CAS 操作（compare and swap），在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏 向于当前线程，所以并不涉及真正的互斥锁。这样做的假设是基于在很多应用 场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低 无竞争开销。 如果有另外的线程试图锁定某个已经被偏斜过的对象，JVM 就需要撤销 （revoke）偏斜锁，并切换到轻量级锁实现。轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步 升级为重量级锁。降级：当JVM 进入安全点（SafePoint）的时候，会检查是否有闲置的 Monitor，然后试图进行降级。

## 自旋锁
竞争失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几次空循环（For (;;)）,循环几轮后，如果可以获得锁，那么进入临界区，如果还是不能获得锁的话，这时候才会在操作系统挂起等待。 一般在 低竞争并且占用锁的时间短的线程很实用。是一种在悲观锁中的乐观优化（因为JVM的synchronized是一种悲观锁 ）。
简单来说，ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。