## ReentrantLock是Lock的实现类，是一个互斥的同步器，在多线程高竞争条件下，ReentrantLock比synchronized有更加优异的性能表现。
1. 用法比较
    1. Lock使用起来比较灵活，但是必须有释放锁的配合动作
    2. Lock必须手动获取与释放锁，而synchronized不需要手动释放和开启锁
    3. Lock只适用于代码块锁，而synchronized可用于修饰方法、代码块等
2. 特性比较 ReentrantLock的优势体现在：
      1. 具备尝试非阻塞地获取锁的特性：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁
      2. 能被中断地获取锁的特性：与synchronized不同，获取到锁的线程能够响应中断，当获取到锁的线程被中断时，中断异常将会被抛出,同时锁会被释放
      3. 超时获取锁的特性：在指定的时间范围内获取锁；如果截止时间到了仍然无法获取锁，则返回

3. 注意事项 在使用ReentrantLock类的时，一定要注意三点：
    1. 在finally中释放锁，目的是保证在获取锁之后，最终能够被释放
    2. 不要将获取锁的过程写在try块内，因为如果在获取锁时发生了异常，异常抛出的同时，也会导致锁无故被释放。
    3. ReentrantLock提供了一个newCondition的方法，以便用户在同一锁的情况下可以根据不同的情况执行等待或唤醒的动作。

## synchronized与ReentrantLock（实现了lock的）区别
在低竞争条件下，synchronized可能会比Reentrantlock效率更高，但是高竞争绝对是Reentrantlock更高。
Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性；使用synchronized关键字时，如果只是读操作也会加锁，因此其他线程无法读，而lock可实现多个线程同时读；Lock可以让等待锁的线程响应中断，避免等待是因为lock可以知道有没有获取到锁，如果没获取到就干其他事去了，避免一直等待；竞争激烈的时候我觉得在可支持同时读这一点上就提升了不少效率啊

## 偏斜锁
当没有竞争的时候，系统会默认使用偏斜锁。JVM 利用CAS（compare and swap）在 对象头的第一部分（mark word）设置 偏向线程ID，表示对象偏向于这个线程。 因为大部分并发场景下面 对象 生命周期 中最多被一个线程锁定， 使用偏斜锁的话可以降低 低竞争状态下的 额外开销。
这个时候如果有另外的线程试图锁定已经被倾斜过的对象，JVM会撤销（revoke）偏斜锁， 并切换到轻量级锁。 这时候轻量级锁 会根据 CAS 操作 Mark word 来试图 获取锁，如果成功就 切换为轻量级锁；否则 进一步 升级 为重量级锁。

## 自旋锁
竞争失败的线程，并不会真实的在操作系统层面挂起等待，而是JVM会让线程做几次空循环（For (;;)）,循环几轮后，如果可以获得锁，那么进入临界区，如果还是不能获得锁的话，这时候才会在操作系统挂起等待。 一般在 低竞争并且占用锁的时间短的线程很实用。是一种在悲观锁中的乐观优化（因为JVM的synchronized是一种悲观锁 ）。