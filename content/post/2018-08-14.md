 Second day of sixth week
=

---

## spring cloud
创建项目的时候，在pom文件中一直识别不了相应的spring cloud包，不明白怎么回事。project一直报错。因为对spring cloud比较好奇所以去网上搜了一下，发现spring boot和cloud的版本支持关系！我使用的spring boot的版本是最新的2.0.4，而spring cloud使用的是Dalston不支持spring boot 2.x。

1. 服务发现的接口DiscoveryClient：Spring Cloud对服务治理做的一层抽象，所以可以屏蔽Eureka和Consul服务治理的实现细节，我们的程序不需要做任何改变，只需要引入不同的服务治理依赖，并配置相关的配置属性就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。
2. RPC是指远程过程调用，也就是说两台服务器A,B,一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不存在同一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。（为什么要用它，因为如果需要在多个计算机进行分布式部署，那么就需要调用不同计算机上的方法了）
    1. 首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。 
    2. 还要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。 
    3. 当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送给B服务器。 
    4. B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。 
    5. 返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用
3. 通过在github上新建的配置文件仓库然后使用spring cloud的config-server来读取，其URL与配置文件的映射关系如下：
    1. /{application}/{profile}[/{label}]
    2. /{application}-{profile}.yml
    3. /{label}/{application}-{profile}.yml
    4. /{application}-{profile}.properties
    5. /{label}/{application}-{profile}.properties
    * tips:上面的url会映射{application}-{profile}.properties对应的配置文件，其中{label}对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支，config-client应用的dev环境，就可以访问这个url：http://localhost:1201/config-client/dev/master
4. 在config客户端这边配置参数与Git中存储的配置文件中各个部分的对应关系如下：
    1. `spring.application.name`：对应配置文件规则中的{application}部分
    2. `spring.cloud.config.profile`：对应配置文件规则中的{profile}部分
    3. `spring.cloud.config.label`：对应配置文件规则中的{label}部分
    4. `spring.cloud.config.uri`：配置中心config-server的地址
    * tips：上面这些属性必须配置在bootstrap.properties中，这样config-server中的配置信息才能被正确加载。
5. 依赖通过远程调用的方式执行，这样就有可能出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致服务瘫痪。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。
6. Hystrix实现服务容错保护：
    1. 降级保护：如果请求服务的时间过长，则不会继续等待那个请求，而是降低要求使用其他请求。
    2. 依赖隔离：为每一个Hystrix命令创建一个独立的线程池，当一个服务请求出现延迟过高不会拖慢整个应用。
    3. 依赖隔离、服务降级在使用时候都是一体化实现的
    4. 断路器：三个重要参数：快照时间窗、请求总数下限、错误百分比下限。这个参数的作用分别是：
        1. 快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。
        2. 请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。
        3. 错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。
    5. 断路器实现：
        1. 那么当断路器打开之后会发生什么呢？我们先来说说断路器未打开之前，对于之前那个示例的情况就是每个请求都会在当hystrix超时之后返回fallback，每个请求时间延迟就是近似hystrix的超时时间，如果设置为5秒，那么每个请求就都要延迟5秒才会返回。当熔断器在10秒内发现请求总数超过20，并且错误百分比超过50%，这个时候熔断器打开。打开之后，再有请求调用的时候，将不会调用主逻辑，而是直接调用降级逻辑，这个时候就不会等待5秒之后才返回fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。
        2. 在断路器打开之后，处理逻辑并没有结束，我们的降级逻辑已经被成了主逻辑，那么原来的主逻辑要如何恢复呢？对于这一问题，hystrix也为我们实现了自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。
        3. 通过上面的一系列机制，hystrix的断路器实现了对依赖资源故障的端口、对降级策略的自动切换以及对主逻辑的自动恢复机制。这使得我们的微服务在依赖外部服务或资源的时候得到了非常好的保护，同时对于一些具备降级逻辑的业务需求可以实现自动化的切换与恢复，相比于设置开关由监控和运维来进行切换的传统实现方式显得更为智能和高效。
7. Dashboard共支持三种不同的监控方式，依次为：
    1. 默认的集群监控：通过URLhttp://turbine-hostname:port/turbine.stream开启，实现对默认集群的监控。
    2. 指定的集群监控：通过URLhttp://turbine-hostname:port/turbine.stream?cluster=[clusterName]开启，实现对clusterName集群的监控。
    3. 单体应用的监控：通过URLhttp://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。
8. turbine配置文件的参数说明：
    1. turbine.app-config参数指定了需要收集监控信息的服务名；
    2. turbine.cluster-name-expression 参数指定了集群名称为default，当我们服务数量非常多的时候，可以启动多个Turbine服务来构建不同的聚合集群，而该参数可以用来区分这些不同的聚合集群，同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需要在Hystrix Stream的URL中通过cluster参数来指定；
    3. turbine.combine-host-port参数设置为true，可以让同一主机上的服务通过主机名与端口号的组合来进行区分，默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计。
9. 更强大一些的均衡负载器--服务网关：将权限控制这样的东西从我们的服务单元中抽离出去