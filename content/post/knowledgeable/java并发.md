## volatile:
1. 如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。
2. Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以，就可能出现线程1改了某个变量的值，但是线程2不可见的情况。Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。
3. volatile是不能保证原子性的。
4. synchronized可以保证原子性、有序性和可见性。而volatile却只能保证有序性和可见性。
5. 线程1在执行monitorenter指令的时候，会对Monitor进行加锁，加锁后其他线程无法获得锁，除非线程1主动解锁。即使在执行过程中，由于某种原因，比如CPU时间片用完，线程1放弃了CPU，但是，他并没有进行解锁。而由于synchronized的锁是可重入的，下一个时间片还是只能被他自己获取到，还是会继续执行代码。直到所有代码执行完。这就保证了原子性。

## synchronized
1. 作用于普通方法
2. 作用于静态方法
3. 作用于代码块
4. 只有在同步的块或者方法中才能调用wait/notify等方法

#### 作用范围
1. 当修饰方法时候，其只作用于本对象实例
2. 当修饰静态方法时，作用于该类的对象（静态方法本就属于这个类，所以任何关于该类的都可）
3. 当修饰代码块时，还是该对象实例

#### 实现原理
1. 每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：
    1. 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。
    2. 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1。
    3. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。
2. 执行monitorexit的线程必须是objectref所对应的monitor的所有者。
    1. 指令执行时，monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。 

## wait,notify,sleep,yield,join方法
1. wait：将当前运行的线程挂起（即让其进入阻塞状态），直到notify或notifyAll方法来唤醒线程.(线程试图等待对象的监视器或者试图通知其他正在等待对象监视器的线程，但本身没有对应的监视器的所有权。wait方法是一个本地方法，其底层是通过一个叫做监视器锁的对象来完成的)所以wait需要拥有监视器（monitor）的所有权的情况下才能调用wait方法（否则报IllegalMonitorStateException异常），怎么获取所有权？=>增加Synchronized关键字，并且是当前对象调用  ====>   Synchronized{object.wait()} 在调用了wait之后线程会释放掉monitor锁
2. notify：与wait同理也要增加Synchronized关键字，并且是当前对象调用
3. sleep：暂时让出CPU的执行权，并不释放Monitor锁，也需要加Synchronized关键字
    1. 通过sleep方法实现的暂停，程序是顺序进入同步块的，只有当上一个线程执行完成的时候，下一个线程才能进入同步方法，sleep暂停期间一直持有monitor对象锁，其他线程是不能进入的。而wait方法则不同，当调用wait方法后，当前线程会释放持有的monitor对象锁，因此，其他线程还可以进入到同步方法，线程被唤醒后，需要竞争锁，获取到锁之后再继续执行。
    2. 如： Sleep start-----线程A
            Sleep end-----A
            Sleep start-----B
            Sleep end-----B
            Sleep start-----C
            Sleep end-----C
            -----分割线-----
            Wait start-----A
            Wait start-----B
            Wait start-----C
            Wait end-----A
            Wait end-----B
            Wait end-----C
4. join阻塞当前正在执行线程，让调用join的方法先执行，执行完毕wake up当前线程