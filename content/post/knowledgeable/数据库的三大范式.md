## 解释：下一NF满足的前提是上一NF要满足。
1. 第一范式要求确保表中每列的`原子性`，也就是`不可拆分`；
2. 第二范式要求确保表中每列与主键相关，而不能只与主键的某部分相关（主要针对联合主键），`主键列与非主键列遵循完全函数依赖关系`，也就是完全依赖；
3. 第三范式确保非主键之间没有依赖关系，也就是消除`传递依赖`。
4. BCNF范式排除了任何属性(不光是非主属性，2NF和3NF所限制的都是非主属性)对候选键的传递依赖与部分依赖。
5. 第四范式

### 第一范式 (1NF)
1. 比如一个表中有一个字段叫做区域，值举例eg:四川省成都市新都区，可以拆分成 省份字段，城市字段，分区字段
2. 当所有的字段都无法拆分的时候，就满足了第一范式，即字段满足原子性。

### 第二范式 (2NF)
1. 比如一个表中有四个字段，eg:订单编号，商品编号，商品名称，数量，两个订单-商品编号作为联合主键
2. 将这个表分成，订单表和商品表，订单表：订单编号-商品编号-数量，商品表：商品编号-商品名称
3. 为什么表一不满足第二范式，因为订单编号和商品编号作为联合主键的话，由于商品名称只与商品编号有关，与订单编号无关，因此与主键（联合主键）无关。

### 第三范式 (3NF)
1. 比如一个表中有，学生与导师关联表，导师ID，导师名称，学生ID，学生名称， 学生ID为主键
2. 将这个表分成导师ID，学生ID，学生名称 和 导师ID，导师名称两张表，
3. 没有 学生ID=>学生名称这个 `传递依赖` 就是第三范式

### 补充范式！

#### BC范式（BCNF）
1. 学生ID，专业，导师，专业GPA，这其中学生ID和专业是联合主键。
2. 这个表的设计满足三范式，有主键，不存在主键的部分依赖，不存在非主键的传递依赖。但是这里存在另一个依赖关系，“专业”函数依赖于“导师”，也就是说每个导师只做一个专业方面的导师，只要知道了是哪个导师，我们自然就知道是哪个专业的了。
3. 这个表的部分主键依赖于非主键部分，那么我们可以进行以下的调整，拆分成2个表,学生导师表：:StudentId	Advisor	MajGPA,导师表：Advisor	Major