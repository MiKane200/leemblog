## 选择排序：
当循环中遇到continue语句会跳转到当前所在循环的下一次迭代，如果想要跳转到外层循环，需要给循环打上标签，然后调用continue并传入外层的标签。如：
```java
void SelectSort(List<Integer> numbers){
        int min;
        for (int i = 0;i < numbers.size() - 1;i++){
            min = i;
            for (int j = i + 1;j < numbers.size() - 1;j++){
                if(numbers.get(min) > numbers.get(j)){
                    min = j;
                }
            }
            if(min != i) {
                int temp = numbers.get(min);
                numbers.set(min,numbers.get(i));
                numbers.set(i,temp);
            }
        }
    }
```

----------------------------------------------------------------

## 正宗冒泡优化排序 =>最好复杂度：O（n),最坏的复杂度=>O（n2)
```java
// flag用来判断是否进行过交换，如果没有调整过j，就说明下面所有的元素都已经是有序的，就不需要进行排序了（省去重复排序有序序列）
boolean flag = true;
for(int i = 0; i < arr.length && flag; i++){
    flag = false;
    for(int j = arr.length - 1; j >= i; j--){
            if(arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                a[j+1] = temp; 
                flag = true;
            }
    }
}
```

## 快排：每一次嗲用操作都是每一个列表的一半=>平均复杂度：O（nlogn),最坏的复杂度=>O（n2)
```java
public static List<Integer> quickSort(List<Integer> numbers){
    //终止条件：如果只有0，或一个元素就不用排序了，直接返回
    if(number.size() < 2)
        return numbers;
    //使用第一个元素对list进行分组
    final Integer pivot = numbers.get(0);
    final List<Integer> lower = new ArrayList<>();
    final List<Integer> higher = new ArrayList<>();

    for(int i=1;i < number.size(); i++){
        if(numbers.get(i) < pivot){
            lower.add(numbers.get(i));
        }else{
            higher.add(numbers.get(i));
        }
    }

    //递归调用：排序小的，加入中间，排序大的并加入，最后返回排序的list
    final List<Integer> sortedLower = quickerSort(lower);

    sortedLower.add(pivot);
    sortedLower.addAll(quickSort(higher));

    return sorted;
}
```

----------------------------------------------------------------

## 直接插入排序 列表本身就是有序的=>最好情况O(n)  列表是逆序的=>最坏情况 ~~ 平均情况 O(n^2)
升序：
先在数组里面抽出 i 位置的空位，赋给temp，然后看前一个如果比它大就，把前一个后移一位到空位，前一个就变成新的空位，然后把再temp跟前一个比较如果重复之前操作，直到j为0或者前一位没有temp大为止。
```java
public void insertionSort(int[] array) {
		for (int i = 1; i < array.length; i++) {
			int temp = array[i];
			int j = i - 1;
			while (j >= 0 && array[j] > temp) {
				array[j + 1] = array[j];
				j--;
			}
			array[j + 1] = temp;
		}
	}
```

## 希尔排序 平均时间复杂度=> O(n^(3/2))
#### 算法思路：
1.  一般取数组长度1/2为间隔距离，对相应间隔距离的数（这个时候在循环i里面），依次进行比较，前一位比后一位大的（这个时候在循环j里面）交换对应位置
2. 当比较到最后一位的时候，再次减半间隔距离，然后重复1操作，直到最后距离为1，比较完成。
```java
    public static void shellSort(int[] array) {
        int number = array.length / 2;
        int i,j,temp;
        while (number >= 1) {
            for (i = number; i < array.length; i++) {
                temp = array[i];
                j = i - number;
                while (j >= 0 && array[j] > temp) {
                    array[j + number] = array[j];
                    j = j - number;
                }
                array[j + number] = temp;
            }
            number = number / 2;
        }
    }
```

----------------------------------------------------------------


## 归并排序
#### 两种：
1.	递归法（Top-down）:将数组递归分割成1/2小块，进行排序。
2.	迭代法（Bottom-up）：依次将数组相邻位置合并成2^n数组，排序，合并。
```java
//递归版
static void merge_sort_recursive(int[] arr, int[] result, int start, int end) {
	if (start >= end)
		return;
	int len = end - start, mid = (len >> 1) + start;
	int start1 = start, end1 = mid;
	int start2 = mid + 1, end2 = end;
	merge_sort_recursive(arr, result, start1, end1);
	merge_sort_recursive(arr, result, start2, end2);
	int k = start;
	while (start1 <= end1 && start2 <= end2)
		result[k++] = arr[start1] < arr[start2] ? arr[start1++] : arr[start2++];
	while (start1 <= end1)
		result[k++] = arr[start1++];
	while (start2 <= end2)
		result[k++] = arr[start2++];
	for (k = start; k <= end; k++)
		arr[k] = result[k];
}
public static void merge_sort(int[] arr) {
	int len = arr.length;
	int[] result = new int[len];
	merge_sort_recursive(arr, result, 0, len - 1);
}


//迭代版
public static void merge_sort(int[] arr) {
  int[] orderedArr = new int[arr.length];
        for (int i = 2; i < arr.length * 2; i *= 2) {
            for (int j = 0; j < (arr.length + i - 1) / i; j++) {
                int left = i * j;
                int mid = left + i / 2 >= arr.length ? (arr.length - 1) : (left + i / 2);
                int right = i * (j + 1) - 1 >= arr.length ? (arr.length - 1) : (i * (j + 1) - 1);
                int start = left, l = left, m = mid;
                while (l < mid && m <= right) {
                    if (arr[l] < arr[m]) {
                        orderedArr[start++] = arr[l++];
                    } else {
                        orderedArr[start++] = arr[m++];
                    }
                }
                while (l < mid)
                    orderedArr[start++] = arr[l++];
                while (m <= right)
                    orderedArr[start++] = arr[m++];
                System.arraycopy(orderedArr, left, arr, left, right - left + 1);
            }
        }
}
```

## 堆排序
```java
public class HeapSort {
    
    private int[] arr;
    
    public HeapSort(int[] arr){
        this.arr = arr;
    }
    
    /**
     * 堆排序的主要入口方法，共两步。
     */
    public void sort(){
        /*
         *  第一步：将数组堆化
         *  beginIndex = 第一个非叶子节点。
         *  从第一个非叶子节点开始即可。无需从最后一个叶子节点开始。
         *  叶子节点可以看作已符合堆要求的节点，根节点就是它自己且自己以下值为最大。
         */
        int len = arr.length - 1;
        int beginIndex = (len - 1) >> 1; 
        for(int i = beginIndex; i >= 0; i--){
            maxHeapify(i, len);
        }
        
        /*
         * 第二步：对堆化数据排序
         * 每次都是移出最顶层的根节点A[0]，与最尾部节点位置调换，同时遍历长度 - 1。
         * 然后从新整理被换到根节点的末尾元素，使其符合堆的特性。
         * 直至未排序的堆长度为 0。
         */
        for(int i = len; i > 0; i--){
            swap(0, i);
            maxHeapify(0, i - 1);
        }
    }
    
    private void swap(int i,int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
    
    /**
     * 调整索引为 index 处的数据，使其符合堆的特性。
     * 
     * @param index 需要堆化处理的数据的索引
     * @param len 未排序的堆（数组）的长度
     */
    private void maxHeapify(int index,int len){
        int li = (index << 1) + 1; // 左子节点索引
        int ri = li + 1;           // 右子节点索引
        int cMax = li;             // 子节点值最大索引，默认左子节点。
        
        if(li > len) return;       // 左子节点索引超出计算范围，直接返回。
        if(ri <= len && arr[ri] > arr[li]) // 先判断左右子节点，哪个较大。
            cMax = ri;
        if(arr[cMax] > arr[index]){
            swap(cMax, index);      // 如果父节点被子节点调换，
            maxHeapify(cMax, len);  // 则需要继续判断换下后的父节点是否符合堆的特性。
        }
    }
    
    /**
     * 测试用例
     * 
     * 输出：
     * [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9]
     */
    public static void main(String[] args) {
        int[] arr = new int[]{3,5,3,0,8,6,1,5,8,6,2,4,9,4,7,0,1,8,9,7,3,1,2,5,9,7,4,0,2,6};        
        new HeapSort(arr).sort();        
        System.out.println(Arrays.toString(arr));
    }
    
}