+++
title = "2018-07-18"
weight = 93
+++

Third Day of second week
=

---

## 早上 

#### 使用mvn命令来编译运行java程序
1. 修改了maven的setting的镜像：      
开始的时候，因为建立模板不成功，（用了公司的仓库和阿里云的），一直下不了模板，所以使用mvn命令一直提示没有插件没有插件~，然后改过去改过来。之后又上午查资料啊，自己琢磨啊，搞了半天，后来直接去中央仓库下的，之后问了老师，网上阿里的大多数人一致认同的那个版本确实链接不到，后来是修改了镜像和公司的库才能链接到。
* tips：修正后的镜像
>
    <mirror>      
          <id>choerodon-maven-repository</id>
          <name>choerodon maven Repository</name>
          <mirrorOf>central</mirrorOf>
          <url>http://nexus.choerodon.com.cn/repository/choerodon-maven/</url>      
    </mirror> 

    <mirror>
       <id>aliyun</id>
        <mirrorOf>central</mirrorOf>
        <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
    </mirror>
>
2. 之后，在编译的时候，以为mvn jar这个插件打包的时候会自动编译，出现了一些错误，然后自己觉得可能是编译的问题又去complie一下，发现运行效果正常了。
3. 使用java -jar 来执行打出来的jar包。

## 下午

#### 用mvn命令运行java的sh脚本编写
* 在下午通过询问同学和上网查资料，进一步优化了自己的运行脚本
>
i=1;
for f in $( ls )
do
    if [ -d "$f" ];then
        cd "$f";
        mvn compile;
        mvn clean package;
        echo 第$i题结果：;
        java -jar target/$f.jar;
        cd ..;
        let i++;
        echo "输入任意键继续";
        read next;
    fi
done
>

#### 设计模式（真·手打理解，尽量简洁）

##### 下午自己看了一大堆设计模式，这里总结一下各自的应用场景：
1. 工厂模式：在任何需要生成复杂对象的地方，都可以使用工厂方法模式。但简单的对象，特别是只需要new一下的就没必要使用工厂模式了。
2. 抽象工厂：相对于工厂模式，灵活性更高，需要创建什么产品才去创建相应的工厂，当需求为在多个产品族中要求一次只得到其中某一类产品时使用此模式。
3. 单例模式：当使用一个全局类并且唯一，而且经常使用到。
4. 建造者模式：单个基类对象经常变化，但多个基类对象组成的整体很少变化。
5. 原型模式：当一个对象的创建需要花费比较大的代价时，缓存改对象，用时再去克隆它。
6. 适配器模式：兼容两个不互相兼容的类。
7. 桥接模式：某个系统或者类分化成多个不同的模块，模块之间又发生不同的变化，使用桥接模式能动态地去选择需要那个变化的模块。
8. 过滤器模式：对于一个需要过滤的集合，需要某种条件的过滤就去生产相应的过滤器过滤。
9. 组合模式：申明一个类，使用这个类来形成树形结构，用户可以用来阐明他希望的组织结构。
10. 装饰器模式：如果你想增加一个类的功能而又不想增加子类。
11. 外观模式：隐藏内部具体的实现方法，只显示执行的结果给客户。
12. 享元模式：程序中需要大量差不多的资源的时候。
13. 代理模式：在访问一个类的时候，去增加控制。
14. 责任链模式：一条请求，多个对象审核。
15. 命令模式：在请求者和处理者之间减少关联（解耦），使一个操作（命令）具体化。
16. 解释器模式：当一个请求或什么操作请求次数过高，使用此模式将不同请求定位到不同的处理方式上。
17. 迭代器模式：当需要对一个遍历的对象内部进行保密时。
18. 中介者模式：将网状结构搞成星状，简化各个类之间的关联时候用。
19. 备忘录模式：当一个事件（对象，操作）需要被undo之类，要求记住状态的时候。
20. 观察者模式：牵一发而动全身（一个动有关系的都要动）。
21. 状态模式：需要大量对象的功能行为因为他的属性变化而变化的时候。
22. 空对象模式：当为null的时候，提供给空对象默认的行为。
23. 策略模式：当类有很多种时，只是通过他们的功能行为来区分。
24. 模板模式：当有很多类使用同一种方法（写成模板）时。
25. 访问者模式：根据访问者的类型来进行不同的反应，当
26. MVC模式：这个不多说。
27. 业务代表模式：将业务和表示的联系减少。
28. 数据访问对象模式：就是DAO，包含三个东西--获取数据操作接口，实现类（获取数据），装数据的pojo。
29. 前端控制器模式：控制，跟踪请求的跳转，过滤，认证请求等各项操作，给dispatcher转发。
30. 拦截过滤器模式：也有过滤，认证请求等各项操作，但使用的地点不同，方式不同。
31. 传输对象模式：需要传输一整个对象时，此对象含有不同的属性值，进行一次性传输。

---

## 晚上
晚上的时候继续上面下午没看完的设计模式，另外还看了java stream和lamdba。
#### lamdba：
1. 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。
2. 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。
3. 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。
4. 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。

* 变量作用域:lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误,可以直接在 lambda 表达式中访问外层的局部变量。局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）。不允许声明一个与局部变量同名的参数或者局部变量。

* stream：
在流的各个节点进行相应的处理：
| stream of elements +-----> |filter+-> |sorted+-> |map+-> |collect|
java:
>
        List<Integer> transactionsIds = 
        widgets.stream()
                    .filter(b -> b.getColor() == RED)
                    .sorted((x,y) -> x.getWeight() - y.getWeight())
                    .mapToInt(Widget::getWeight)
                    .sum();
>
